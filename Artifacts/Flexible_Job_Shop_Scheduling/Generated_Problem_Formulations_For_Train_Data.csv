prompt,completion,result,index_numbers,generated_code
"I'm looking for help to develop a schedule for Shiny Printing Factory, prioritizing the minimization of makespan. The job information is available in the source.txt file. After the schedule is completed, please arrange for the solutions to be printed and displayed visually.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",6,3,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
#
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
#
#
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our priority is to establish an efficient schedule for Shiny Factory that minimizes maximum tardiness. The job specifications, detailed in the source-quantity.txt file, cover various quantities labeled as very small, small, and large. To streamline operations, we've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine manages those with small quantities. However, it's important to recognize that jobs exceeding a machine's capacity won't be processed by that machine. Moreover, due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3, complicating the scheduling process. Additionally, with jobs having random release times, the scheduling challenge is further amplified. Following successful resolution of these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",3,39,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small','small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine!= 13 and machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
#
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our objective is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job specifications are stored in source_machine_13.txt. However, there's a unique twist: the jobs come with random release times. Additionally, we have a specific constraint regarding the 7-Head Machine: if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the problem is resolved, it's essential to print and visualize the solutions for thorough analysis.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine != 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 2)         
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",7,15,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine!= 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
#
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 2)         
    return m
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our objective is to develop an optimized schedule for Shiny Factory, with the aim of minimizing maximum tardiness. The job details are provided in source.txt. It's crucial to note that due dates are computed by multiplying each job's total processing time by a factor of 1.3. Once we address these challenges, thorough documentation and visual representation of the solutions will be essential for better comprehension and analysis.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
due_date_allowance = 1.3
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
horizon = get_horizon(jobs)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",0,41,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
due_date_allowance = 1.3
#
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
horizon = get_horizon(jobs)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
#
#
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We need to develop a schedule for Shiny Factory that focuses on minimizing makespan. The job specifications are detailed in the source_machine_13.txt file, but there's a unique challenge: the jobs have random release times. Additionally, for the 7-Head Machine, if it has more than 2 units of waiting time, we should consider utilizing another machine. Once the schedule is completed, ensure that the solutions are printed and visually presented for a thorough analysis.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine != 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 2)         
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",7,19,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine!= 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
#
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 2)         
    return m
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our task is to optimize the scheduling system for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The allocation of tasks to machinesLittle Fang Machine for very small jobs and 7-Head Machine for small onesis predetermined. However, a specific constraint is in place for the 7-Head Machine: if its waiting time exceeds three units, alternative machine options must be considered. Due dates for jobs are calculated by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, the stochastic nature of job release times introduces another layer of complexity. Our objective is to devise an optimization strategy that effectively addresses these challenges, ultimately ensuring efficient scheduling and minimal tardiness. Thorough documentation and visual representation of the solutions will be critical for evaluating the effectiveness of our approach.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",3,49,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small','small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                        for machine in machines:
                            if machine!= 13 and machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"I need to develop a schedule for Shiny Factory in order to optimise makespan. The job details are conveniently stored in the source.txt file. Once the problem is resolved, could you ensure that the solutions are both printed and visually represented for thorough analysis?","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",6,0,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
#
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
#
#
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We need to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. Our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Once this task is completed, please ensure the solutions are meticulously documented and visually illustrated.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",6,9,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
quantity_types = ['very_small','small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine!= 13 and machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
#
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We're looking to develop a schedule for Shiny Factory with the objective function centered around minimizing makespan. The pertinent job information is accessible in source.txt. However, there's a complexity: the jobs come with random release times. Could you please incorporate this detail into your optimization approach? Once the problem is solved, it's imperative that the solutions are both printed and visually represented for comprehensive evaluation.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]         
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",7,10,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
#
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]         
    return m
#
#
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We are endeavoring to construct a schedule for Shiny Factory with the primary objective of minimizing maximum tardiness. The job particulars are contained within source.txt. However, the challenge lies in the intricacies: due dates are computed based on the cumulative processing time of each job, multiplied by a due date allowance factor of 1.3. Moreover, these jobs exhibit random release times. Once the problem has been successfully resolved, it is imperative that the solutions are documented and visualized for comprehensive evaluation.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",4,21,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
#
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
#
#
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We need to create a schedule for Shiny Factory that aims to minimize makespan. The job details are in the source_machine_13.txt file, but there's a twist: the jobs have random release times. Plus, there's a constraint with the 7-Head Machine. if it has more than 2 units of waiting time, we should look at using another machine. Once we figure this out, make sure to print out the solutions and show them visually for a thorough analysis.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine != 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 2)         
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",7,17,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine!= 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
#
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 2)         
    return m
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our objective is to create an optimized schedule for Shiny Factory, with the primary aim of minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are outlined in the source-quantity.txt file. The Little Fang Machine is designated to handle very small jobs, while the 7-Head Machine is tasked with managing small ones. However, it's important to note that if a job's quantity exceeds a machine's capacity, it won't be processed by that machine. Additionally, we have established a specific criterion for the 7-Head Machineif its waiting time exceeds three units, alternative machine options will be considered. The due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3, and jobs will have random release times, adding complexity to the scheduling process. Once we successfully address these challenges, thorough documentation and visual representation of the solutions will be essential for comprehensive evaluation.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",3,47,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small','small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                        for machine in machines:
                            if machine!= 13 and machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our goal is to develop a schedule for Shiny Factory with the objective function focused on maximum tardiness. The job details are stored in source.txt. However, there are specific complexities to consider: the due dates are derived from the total processing time of each job, multiplied by a due date allowance of 1.3. Additionally, the jobs have random release times.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",4,20,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
#
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
#
#
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our goal is to make a schedule for Shiny Factory that keeps the maximum tardiness as low as possible. The job details are in source.txt. Something important to remember is that we calculate due dates by multiplying each job's total processing time by 1.3. Once we sort out these challenges, we need to make sure we document everything well and show it visually so we can understand it better.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
due_date_allowance = 1.3
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
horizon = get_horizon(jobs)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",0,40,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
due_date_allowance = 1.3
#
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
horizon = get_horizon(jobs)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
#
#
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our overarching goal is to optimize the schedule for Shiny Factory, prioritizing the minimization of maximum tardiness. The job specifications are outlined in source.txt. A critical factor to consider is that due dates are determined by multiplying each job's total processing time by a factor of 1.3. Upon resolving these challenges, it's essential to prioritize comprehensive documentation and visual representation of the solutions for thorough evaluation.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
due_date_allowance = 1.3
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
horizon = get_horizon(jobs)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",0,44,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
due_date_allowance = 1.3
#
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
horizon = get_horizon(jobs)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
#
#
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We're working on making a schedule for Shiny Factory to minimize the makespan. The job details are in source_machine_13.txt, but there's an added complexity: each job has a random release time. Plus, there's a special condition for the 7-Head Machine. If its waiting time goes over three units, we need to look at using a different machine. After we solve the scheduling problem, we need to print out the solutions and show them visually for a thorough review.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine != 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",7,26,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine!= 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
#
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We're tasked with creating a schedule for Shiny Factory to minimize the makespan. The job details are outlined in source_machine_13.txt. However, there's an added challenge: each job has a random release time. Additionally, we've established a specific criterion for the 7-Head Machineif its waiting time exceeds three units, we should explore alternative machine options. Once we address this scheduling issue, it's crucial to document and visually represent the solutions for comprehensive analysis.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine != 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",7,27,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine!= 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
#
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our objective is to establish a schedule for Shiny Factory that prioritizes minimizing the makespan. The job details are documented in source_machine_13.txt. However, we face a notable complexity: each job possesses a random release time. Furthermore, we have set a specific condition for the 7-Head Machineif its waiting time surpasses three units, alternative machine options should be considered. Upon resolving this scheduling challenge, it is imperative that we meticulously document and visually present the solutions for comprehensive analysis.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine != 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",7,28,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# waiting time related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    for machine in machines:
                        if machine!= 13:
                            jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source_machine_13.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
#
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We're looking to develop a schedule for Shiny Factory that prioritizes minimizing makespan. The job information is available in the source.txt file. However, there's a complexity: the jobs have random release times. Please incorporate this detail into your optimization approach. Once the problem is solved, make sure the solutions are printed and visually represented for a thorough evaluation.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]         
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",7,14,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
#
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]         
    return m
#
#
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our primary objective is to establish an efficient schedule for Shiny Factory that minimizes the maximum tardiness. The job details are available in source.txt. It's important to note that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we successfully address these challenges, it's imperative to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
due_date_allowance = 1.3
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
horizon = get_horizon(jobs)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",0,43,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
due_date_allowance = 1.3
#
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
horizon = get_horizon(jobs)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
#
#
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We need a schedule for Shiny Factory that focuses on minimizing makespan. The job details are in the source-quantity.txt file, with each job categorized as very small, small, or large in quantity. The Little Fang Machine specializes in very small quantities, while the 7-Head Machine processes small quantities. If a job exceeds a machine's capacity, it won't be processed by that machine. Once this task is completed, please ensure the solutions are thoroughly documented and visually illustrated.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",6,7,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
quantity_types = ['very_small','small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine!= 13 and machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
#
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our job is to create a schedule for Shiny Factory, focusing on minimizing makespan. We've got the job details in the source-quantity.txt file, categorized as very small, small, and large quantities. The Little Fang Machine takes care of very small tasks, and the 7-Head Machine handles the small ones. But if a job's quantity is too big for a machine, it won't get processed there. Also, the jobs have random release times. Once we tackle this, we need to make sure the solutions are written down and shown visually.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",8,31,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
quantity_types = ['very_small','small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine!= 13 and machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
#
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"I need help creating a schedule for Shiny Printing Factory with a focus on minimizing the makespan. The job details are provided in the source.txt file. Once the schedule is finalized, please ensure the solutions are printed and visually presented.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",6,2,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
#
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
#
#
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We're tasked with crafting a schedule for Shiny Factory, focusing on minimizing makespan. The job details are outlined in the source-quantity.txt file. These jobs come with quantity labels, including very small, small, and large. Specifically, tasks labeled as very small quantities will be handled by the Little Fang Machine, while the 7-Head Machine will manage small quantities. However, if either machine receives a quantity beyond its capacity, the job will not be processed by the machine. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",6,5,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
quantity_types = ['very_small','small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine!= 13 and machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
#
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We're working on making a schedule for Shiny Factory to minimize maximum tardiness. The job details are in source.txt. The tricky part is that due dates are calculated based on the total processing time of each job, multiplied by a due date allowance factor of 1.3, and the jobs have random release times. After we figure this out, we need to make sure the solutions are written down and shown visually for a thorough review.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",4,22,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
#
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
#
#
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our main task is to create a schedule for Shiny Factory that minimizes the maximum tardiness. All the job details are stored in source.txt. A key thing to keep in mind is that due dates are calculated by multiplying each job's total processing time by a factor of 1.3. Once we overcome these challenges, it's crucial to document everything thoroughly and visually represent the solutions for a comprehensive evaluation.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
due_date_allowance = 1.3
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
horizon = get_horizon(jobs)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",0,42,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
due_date_allowance = 1.3
#
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
horizon = get_horizon(jobs)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
#
#
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our job is to set up a schedule for Shiny Factory to cut down on maximum tardiness. The job details are in the source-quantity.txt file, with labels like very small, small, and large. The Little Fang Machine deals with the very small ones, and the 7-Head Machine handles the small ones. But if a job is too big for a machine, it won't handle it. We figure out due dates by multiplying the total processing time of each job by 1.3. Plus, the jobs have random release times. Once we tackle this, we'll make sure the solutions are written down and shown visually.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",3,37,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small','small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine!= 13 and machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
#
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We're in need of a schedule for Shiny Factory that prioritizes minimizing makespan. The job specifications are stored in source-quantity.txt file, with each job labeled as very small, small, or large in quantity. Notably, our Little Fang Machine specializes in processing very small quantities, while the 7-Head Machine handles small quantities. Should either machine encounter a quantity exceeding its capacity, the machine will not be processed by the machine. Following the resolution of this task, we aim to have the solutions meticulously documented and visually illustrated.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",6,6,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
quantity_types = ['very_small','small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine!= 13 and machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
#
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"I need some help making a schedule for Shiny Printing Factory to keep the makespan as short as possible. The job details are all in the source.txt file. After it's done, can you print out the solutions and show them to us visually? Thanks!","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",6,4,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
#
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_horizon(jobs):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return horizon
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
horizon = get_horizon(jobs)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    return m
#
#
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our task is to develop a schedule for Shiny Factory with the aim of minimizing makespan. The job details are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. Specifically, the Little Fang Machine will handle tasks labeled as very small quantities, while the 7-Head Machine will manage small quantities. However, if a job's quantity exceeds the capacity of either machine, that job will not be processed by that machine. Additionally, the jobs have random release times. After addressing this challenge, we need to ensure that the solutions are both documented and visually represented.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",8,30,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
quantity_types = ['very_small','small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine!= 13 and machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
#
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our priority is to establish a schedule for Shiny Factory with the overarching goal of minimizing makespan. The job particulars, categorized by quantity labelsvery small, small, and largeare outlined in the source-quantity.txt file. We've designated the Little Fang Machine for handling tasks labeled as very small quantities, while the 7-Head Machine is tasked with managing small quantities. However, it's essential to recognize that if a job's quantity exceeds the capacity of either machine, it will not be processed there. Adding to the complexity, the jobs also come with random release times. Once we successfully navigate these challenges, it's critical to meticulously document the solutions and present them visually for comprehensive evaluation.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",8,33,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
quantity_types = ['very_small','small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine!= 13 and machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
#
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We are tasked with creating a schedule for Shiny Factory that aims to minimize maximum tardiness. The job specifications are provided in the source-quantity.txt file and include quantity labels such as very small, small, and large. The Little Fang Machine will handle jobs labeled as very small quantities, while the 7-Head Machine will manage those with small quantities. If a job's quantity exceeds a machine's capacity, it will not be processed by that machine. Furthermore, we have a special condition for the 7-Head Machine: if its waiting time exceeds three units, we need to consider using a different machine. Due dates are determined by multiplying each job's total processing time by a due date allowance of 1.3. Additionally, jobs will have random release times. Once we've successfully tackled this challenge, we'll ensure that the solutions are documented and visually represented.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",3,45,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small','small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                        for machine in machines:
                            if machine!= 13 and machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"We're seeking to develop a schedule for Shiny Factory with a primary objective of minimizing makespan. The job specifications are contained within source.txt. However, there's a notable complexity: the jobs feature random release times. Following the resolution of this problem, it's essential to have the solutions printed and visually presented for thorough analysis.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]         
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",7,11,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
#
#
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]         
    return m
#
#
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our objective is to develop a schedule for Shiny Factory aimed at minimizing makespan. The job details are provided in the source-quantity.txt file, categorized by quantity labels: very small, small, and large. Specifically, the Little Fang Machine is designated for tasks labeled as very small quantities, while the 7-Head Machine is allocated for small quantities. However, it's crucial to note that if a job's quantity exceeds the capacity of either machine, it will not be processed by that machine. Additionally, the jobs have random release times, adding to the complexity of the task. Upon successfully addressing these challenges, it's imperative that we document the solutions thoroughly and present them visually for comprehensive evaluation.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",8,32,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
quantity_types = ['very_small','small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]!='small'):
                        for machine in machines:
                            if machine!= 13 and machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
#
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    m = Model()
    return m, (starts, ends)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
#
#
# define objective
def objective(m, ends):
    m.minimize(max(ends))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends)) = model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = objective(model, ends)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Makespan:"", max([b for a in ([e.value() for e in ends]) for b in a]))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
"Our priority is to optimize the scheduling process for Shiny Factory, focusing on minimizing maximum tardiness. The job specifications, categorized by quantity labels such as very small, small, and large, are detailed in the source-quantity.txt file. We've allocated the Little Fang Machine for very small jobs and the 7-Head Machine for small ones. However, we've implemented a specific guideline for the 7-Head Machineif its waiting time surpasses three units, alternative machine options will be explored. Due dates for jobs are determined by multiplying each job's total processing time by a due date allowance factor of 1.3. Additionally, jobs will have random release times, adding another layer of complexity to the scheduling process. Once we successfully address these challenges, it's crucial to ensure thorough documentation and visual representation of the solutions for comprehensive evaluation.","# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small', 'small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                        for machine in machines:
                            if machine != 13 and machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine != 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)",3,48,"
# imports
import numpy as np
import pandas as pd
import plotly.express as px
from cpmpy import *
import random
import itertools
from itertools import permutations
from pathlib import Path
import ast
# configurations
random.seed(1)
duration = []
preference = []
maximum_release_time = 5
due_date_allowance = 1.3
quantity_types = ['very_small','small', 'large']
machines = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
            20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,37,38,39,40,41,42,43,44]
# quantity related utility functions
def special_adjustment_for_machine_13(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==13:
                        for machine in machines:
                            if machine!= 13 and machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
def special_adjustment_for_machine_16(jobs, num_jobs, machines):
    for i in range(0, num_jobs):
        for j in range(0, len(jobs[i])):
            for k in range(0,len(jobs[i][j])):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]!='very_small'):
                        for machine in machines:
                            if machine!= 16:
                                jobs[i][j].append((jobs[i][j][k][0], machine))
    return jobs
# utility functions
def get_jobs():
    # data input, each job have several operations and each operation can be processed by one of the alternative machines.
    return ast.literal_eval(Path('source-quantity.txt').read_text())
def get_job_count(jobs):
    return len(jobs)
def get_quantities_per_job(num_jobs, quantity_types):
    quantities_per_job = []
    for i in range(0, num_jobs):
        quantities_per_job.append(quantity_types[random.randint(0, len(quantity_types)-1)])
    return quantities_per_job
def get_number_of_tasks(jobs, num_jobs):
    return [len(jobs[i]) for i in range(0, num_jobs)]
def get_number_of_preferences(jobs, num_tasks, num_jobs):
    return [[len(jobs[i][j]) for j in range(0, num_tasks[i])] for i in range(0, num_jobs)]
def get_due_dates(due_date_allowance, maximum_durations):
    return (0 + due_date_allowance*np.asarray(maximum_durations)).astype(int).tolist()
def get_release_times(num_jobs, maximum_release_time):
    release_times = []
    for i in range(0, num_jobs):
        release_times.append(random.randint(0, maximum_release_time))
    return release_times
def get_horizon(jobs, release_times):
    horizon = 0 # maximum time to process all jobs (use the )
    for job in jobs:
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            horizon += max_task_duration
    return (horizon + sum(release_times))
# tardiness related utility functions
def get_maximum_durations(jobs):
    maximum_durations = []
    for job in jobs:
        maximum_duration_per_job = []
        for task in job:
            max_task_duration = 0
            for alternative in task:
                max_task_duration = max([max_task_duration, alternative[0]])
            maximum_duration_per_job.append(max_task_duration)
        maximum_durations.append(np.sum(maximum_duration_per_job))   
    return maximum_durations
# data preparation
jobs = get_jobs()
num_jobs = get_job_count(jobs)
quantities_per_job = get_quantities_per_job(num_jobs, quantity_types)
jobs = special_adjustment_for_machine_13(jobs, num_jobs, machines)
jobs = special_adjustment_for_machine_16(jobs, num_jobs, machines)
num_tasks = get_number_of_tasks(jobs, num_jobs)
num_preferences = get_number_of_preferences(jobs, num_tasks, num_jobs)
maximum_durations = get_maximum_durations(jobs)
due_dates = get_due_dates(due_date_allowance, maximum_durations)
release_times = get_release_times(num_jobs, maximum_release_time)
horizon = get_horizon(jobs, release_times)
# define model
def get_model(horizon, num_tasks, num_jobs):
    starts = [intvar(0, horizon, shape=num_tasks[i], name=f""start_{i}"") for i in range(0, num_jobs)]
    ends = [intvar(0, horizon, shape=num_tasks[i], name=f""end_{i}"") for i in range(0, num_jobs)]
    tardiness = intvar(0, horizon, shape=(num_jobs), name=""tardiness"")
    m = Model()
    return m, (starts, ends, tardiness)
# define preference constraints
def define_preference_constraints(jobs, m):
    i=0
    j=0
    for job in jobs:
        temp_dur = []
        temp_st = []
        temp_en = []
        temp_pref = []
        j=0
        for task in job:
            min_duration = task[0][0]
            max_duration = task[0][0]
            k=0
            temp_choice = []
            for choice in task:
                min_duration = min([min_duration, choice[0]])
                max_duration = max([max_duration, choice[0]])
                t_c = boolvar(shape=1, name=f""ch_{i}_{j}_{k}"")
                temp_choice.append(t_c)
                k = k + 1
            dur = intvar(min_duration, max_duration, shape=1, name=f""dur_{i}_{j}"")
            b = 0
            c = 0
            for a in range(0, len(temp_choice)):
                b = b + temp_choice[a]
                c = c + temp_choice[a]*task[a][0]
            m += (b == 1)
            m += (c == dur)
            m += (ends[i][j] == starts[i][j] + dur)
            temp_dur.append(dur)
            temp_pref.append(temp_choice)
            j = j + 1
        duration.append(temp_dur)
        preference.append(temp_pref)
        i = i + 1
    return m
# define overlapping constraints
def define_overlapping_constraints(m, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times):
    for j in range(num_jobs):
        for t in range(num_tasks[j]):
            for j2 in range(num_jobs):
                for t2 in range(num_tasks[j2]):
                    if (j!= j2):
                        combinations = list(itertools.product([v for v in range(0, num_preferences[j][t])],
                                                              [v for v in range(0, num_preferences[j2][t2])]))
                        for combination in combinations:
                            a = combination[0]
                            b = combination[1]
                            if (jobs[j][t][a][1]==jobs[j2][t2][b][1]):
                                m += ((preference[j][t][a]*ends[j][t]) <= (preference[j2][t2][b]*starts[j2][t2])) | ((preference[j2][t2][b]*ends[j2][t2]) <= (preference[j][t][a]*starts[j][t]))
    for i in range(0, num_jobs):
        for t in range(num_tasks[i] - 1):
            m += [starts[i][t + 1] >= ends[i][t]]
    for i in range(0, num_jobs):
        m += starts[i][0] >= release_times[i]
    return m
# define quantity constraints
def define_quantity_constraints(m, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs):
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    if (quantities_per_job[i]=='small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    for i in range(0, num_jobs):
        for j in range(0, num_tasks[i]):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==16:
                    if (quantities_per_job[i]=='very_small'):
                        m += (preference[i][j][k]==1)
                    else:
                        m += (preference[i][j][k]==0)
    return m
# define waiting time constraints
def define_waiting_time_constraints(m, num_jobs, num_preferences, jobs, starts, release_times):
    for i in range(0, num_jobs):
        for j in range(0, 1):
            for k in range(0,num_preferences[i][j]):
                if jobs[i][j][k][1]==13:
                    m += ((preference[i][j][k]*starts[i][j]) - (preference[i][j][k]*release_times[i]) <= 3)         
    return m
def tardiness_constraints(m, num_jobs, tardiness, due_dates):
    for j in range(num_jobs):
        m += (tardiness[j] == max([ends[j][(num_tasks[j] -1)] - due_dates[j], 0]))
    return m
# define objective
def objective(m, tardiness):
    m.minimize(max(tardiness))
    return m
# define visualization
def visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs):
    df = pd.DataFrame(columns=('Start', 'End', 'Machine', 'Job', 'Name'))
    for job_id in range(0, num_jobs):
            for task_id in range(num_tasks[job_id]):
                for alt_id in range(num_preferences[job_id][task_id]):
                    if ((preference[job_id][task_id][alt_id]).value()):
                        machine = jobs[job_id][task_id][alt_id][1]
                        selected = alt_id
                df.loc[ len(df) ] = [(starts[job_id][task_id]).value(), (ends[job_id][task_id]).value(),
                                     machine, f""Job {job_id}"", f""task {job_id} {task_id}""]
                print(
                    ""  task_%i_%i starts at %i (alt %i, machine %i, duration %i)""
                    % (job_id, task_id, (starts[job_id][task_id]).value(), selected, machine,
                       (duration[job_id][task_id]).value())
                )
    df['Time'] = df['End'] - df['Start']  # Length on x-axis

    fig = px.bar(df, orientation='h',
                 base=""Start"", x=""Time"", y=""Machine"", color=""Job"", text=""Name"")
    for i in range(len(fig['data'])):
        fig['data'][i].width = 5
    fig.show() 
# solve
(model, (starts, ends, tardiness)) = get_model(horizon, num_tasks, num_jobs)
model = define_preference_constraints(jobs, model)
model = define_overlapping_constraints(model, jobs, num_jobs, num_tasks, num_preferences, starts, ends, release_times)
model = define_quantity_constraints(model, num_jobs, num_tasks, num_preferences, quantities_per_job, jobs)
model = define_waiting_time_constraints(model, num_jobs, num_preferences, jobs, starts, release_times)
model = tardiness_constraints(model, num_jobs, tardiness, due_dates)
model = objective(model, tardiness)
sat = model.solve()
if not sat: raise Exception(""No solution found."")

# output
print(""Max Tardiness:"", max(tardiness.value()))
print(""Start times:"", [list(s.value()) for s in starts])
print(""End times:"", [list(e.value()) for e in ends])
# visualize
visualize(ends, starts, num_jobs, num_tasks, num_preferences, preference, jobs)"
